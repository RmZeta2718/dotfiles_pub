#!/usr/bin/env python3
"""
cs — 在本地、通过 VSCode IPC，或生成 SSH Remote 链接来打开 Cursor/VSCode。

工作流程优先级
1) 本地启动：直接调用本机 `cursor`/`code` 打开给定路径。
2) VSCode IPC：通过 IPC（依赖 `socat`）将请求转发到本机 VSCode。
3) 远程链接：若以上均不可用，生成并打印可点击的 SSH Remote URI（OSC 8）。

主机别名解析顺序
- 读取环境变量 `SSH_HOST_ALIAS`
- 解析 `~/.ssh/config` 与 `~/.ssh/config_local`，匹配当前 SSH 会话的 Host
- 回退为当前主机名（去掉域名后缀）

依赖
- 已安装 `cursor` 或 `code`（用于本地启动）
- IPC 模式需要 `socat`（实现见 `code_connect.py`）

示例
  cs                    # 打开当前目录
  cs /work              # 打开指定目录
  cs --vs               # 使用 VSCode 打开
  cs /work --debug      # 打印调试信息
"""

import argparse
import os
import re
import socket
import subprocess
import sys
from pathlib import Path
from shutil import which

from code_connect import ensure_socat_is_in_PATH, launch_code_over_ipc


def parse_ssh_config(config_path: Path):
    """
    解析 SSH 配置文件，提取 Host 别名到配置项的映射。

    Args:
        config_path: SSH 配置文件路径。

    Returns:
        dict: Host 别名到配置项的字典。例如 `{ "prod": {"hostname": "1.2.3.4", ...} }`。
    """
    config = {}
    current_hosts = []

    # 如果配置文件不存在，返回空字典
    if not config_path.exists():
        return config

    try:
        with open(config_path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()

                # 跳过空行和注释
                if not line or line.startswith("#"):
                    continue

                # 处理Host行
                if line.lower().startswith("host "):
                    current_hosts = line.split()[1:]
                    for host in current_hosts:
                        config.setdefault(host, {})
                # 处理配置项
                elif current_hosts:
                    parts = re.split(r"\s+", line, 1)
                    if len(parts) < 2:
                        continue
                    key, value = parts[0].lower(), parts[1].strip()
                    for host in current_hosts:
                        config[host][key] = value
    except Exception as e:
        print(f"警告: 解析SSH配置时出错 ({config_path}): {e}", file=sys.stderr)

    return config


def get_connection_info():
    """
    从环境变量读取当前 SSH 连接信息。

    Returns:
        dict | None: 若在 SSH 会话中，返回 `{ "server_ip", "server_port", "user" }`；否则返回 None。

    Notes:
        依赖 `SSH_CONNECTION` 环境变量。
    """
    ssh_conn = os.getenv("SSH_CONNECTION")
    if not ssh_conn:
        return None

    parts = ssh_conn.split()
    if len(parts) < 4:
        print("错误: SSH_CONNECTION格式无效", file=sys.stderr)
        return None

    return {
        "server_ip": parts[2],
        "server_port": parts[3],
        "user": os.getenv("USER", ""),
    }


def find_matching_host(ssh_config, conn_info, debug=False):
    """
    在 SSH 配置中查找与当前连接信息匹配的 Host 别名。

    Args:
        ssh_config: 由 `parse_ssh_config` 返回的配置字典。
        conn_info: 由 `get_connection_info` 返回的连接信息。
        debug: 是否输出调试日志。

    Returns:
        str | None: 匹配到的 Host 别名；未匹配到则返回 None。
    """
    if not conn_info:
        return None

    for host, config in ssh_config.items():
        # 跳过通配符Host
        if "*" in host or "?" in host:
            continue

        # 调试信息
        if debug:
            print(f"调试: 检查主机 '{host}': {config}", file=sys.stderr)

        # 检查HostName是否匹配
        host_ip = config.get("hostname", "")
        if host_ip != conn_info["server_ip"]:
            # 尝试解析主机名
            try:
                resolved_ip = socket.gethostbyname(host_ip)
                if resolved_ip == conn_info["server_ip"]:
                    if debug:
                        print(f"调试: 主机名 '{host_ip}' 解析为匹配的IP '{resolved_ip}'", file=sys.stderr)
                else:
                    if debug:
                        print(f"调试: IP不匹配 ({host_ip} != {conn_info['server_ip']})", file=sys.stderr)
                    continue
            except socket.gaierror:
                if debug:
                    print(f"调试: 无法解析主机名 '{host_ip}'", file=sys.stderr)
                continue

        # 检查端口是否匹配（默认22）
        config_port = config.get("port", "22")
        if config_port != conn_info["server_port"]:
            if debug:
                print(f"调试: 端口不匹配 ({config_port} != {conn_info['server_port']})", file=sys.stderr)
            continue

        # 检查用户是否匹配（如果配置中存在）
        if "user" in config and config["user"] != conn_info["user"]:
            if debug:
                print(f"调试: 用户不匹配 ({config['user']} != {conn_info['user']})", file=sys.stderr)
            continue

        if debug:
            print(f"调试: 找到匹配的主机 '{host}'", file=sys.stderr)
        return host

    return None


def parse_args():
    parser = argparse.ArgumentParser(
        prog="cs",
        description=(
            "在本地、通过 VSCode IPC，或生成 SSH Remote 链接打开 Cursor/VSCode。\n"
            "SSH 会话下可通过 SSH_HOST_ALIAS 或 ssh config 推断主机别名。"
        ),
        epilog=(
            "示例：\n"
            "  cs                    # 在当前目录打开 Cursor\n"
            "  cs /path/to/dir       # 在指定目录打开 Cursor\n"
            "  cs --vs               # 在当前目录打开 VSCode\n"
            "  cs /path/to/dir --vs  # 在指定目录打开 VSCode\n"
            "  cs --debug            # 启用调试输出"
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("path", nargs="?", default=".")
    parser.add_argument("--vs", action="store_true", help="使用VSCode而不是Cursor")
    parser.add_argument("--debug", action="store_true", help="启用调试输出")
    args = parser.parse_args()

    args.path = Path(args.path).resolve()
    if not args.path.exists():
        print(f"错误: 路径不存在: {args.path}", file=sys.stderr)
        sys.exit(1)
    return args


def get_host_alias(debug=False):
    """根据优先级获取主机别名。

    优先级：
    1) 环境变量 `SSH_HOST_ALIAS`
    2) SSH 配置匹配项（来自 `~/.ssh/config` 与 `~/.ssh/config_local`）
    3) 本机主机名（去掉域名后缀）
    """
    # 1. 检查环境变量
    host_alias = os.getenv("SSH_HOST_ALIAS")
    if host_alias:
        if debug:
            print(f"调试: 使用环境变量SSH_HOST_ALIAS: {host_alias}", file=sys.stderr)
        return host_alias

    # 2. 获取连接信息
    conn_info = get_connection_info()

    # 3. 解析SSH配置
    ssh_config = {}
    for config_file in ["config", "config_local"]:
        config_path = Path.home() / ".ssh" / config_file
        config = parse_ssh_config(config_path)
        ssh_config.update(config)

        if debug and config:
            print(
                f"调试: 加载SSH配置 ({config_path}): {len(config)} 个主机",
                file=sys.stderr,
            )

    # 4. 查找匹配的主机
    host_alias = find_matching_host(ssh_config, conn_info, debug)

    if host_alias:
        if debug:
            print(f"调试: 使用SSH配置中的主机别名: {host_alias}", file=sys.stderr)
        return host_alias

    # 5. 使用主机名作为后备
    host_alias = socket.gethostname()
    if "." in host_alias:
        host_alias = host_alias.split(".")[0]

    if debug:
        print(f"调试: 使用主机名作为别名: {host_alias}", file=sys.stderr)

    return host_alias


def launch_local_editor(args):
    """尝试在本地直接启动编辑器。"""
    editor = "code" if args.vs else "cursor"
    if not which(editor):
        return -1
    if args.debug:
        print(f"调试: 在本地启动 {editor}: {args.path}", file=sys.stderr)
    return subprocess.run([editor, args.path]).returncode


def launch_editor_over_ipc(args):
    """通过 VSCode IPC 转发请求以在本机 VSCode 打开路径。"""
    ensure_socat_is_in_PATH()
    try:
        # run the code binary with the args of the current script and exit with the same return code
        return launch_code_over_ipc([args.path])
    except SystemExit as e:  # catch python exit
        return e.code


def generate_remote_uri(host_alias, path, use_vscode=False, debug=False):
    editor_prefix = "vscode" if use_vscode else "cursor"
    uri = f"{editor_prefix}://vscode-remote/ssh-remote+{host_alias}{path}"

    if debug:
        print(f"调试: 生成URI: {uri}", file=sys.stderr)

    return uri


def print_remote_uri(args):
    # 在SSH会话中，获取主机别名
    host_alias = get_host_alias(args.debug)
    if not host_alias:
        print("错误: 无法确定主机别名", file=sys.stderr)
        return -1

    # 生成并输出编辑器URI
    uri = generate_remote_uri(host_alias, args.path, args.vs, args.debug)

    # 输出可点击链接
    print("\n请点击以下链接打开编辑器（或手动复制链接，在浏览器中打开）：\n")
    print(f"\033]8;;{uri}\033\\{uri}\033]8;;\033\\")
    return 0


def main():
    args = parse_args()
    # 本地启动编辑器
    if launch_local_editor(args) == 0:
        return
    # 在远程启动编辑器
    if launch_editor_over_ipc(args) == 0:
        return
    if print_remote_uri(args) == 0:
        return
    print("错误: 无法启动编辑器", file=sys.stderr)


if __name__ == "__main__":
    main()
