#!/usr/bin/env python

import argparse
import os

def main():
    args = parse_args()
    confirm(args)
    if args.push:
        push(args)
    elif args.pull:
        pull(args)
    else:
        assert False, 'Neither push or pull'

def push(args):
    call_rsync(args.src, f'{args.remote}{args.dst}')

def pull(args):
    call_rsync(f'{args.remote}{args.src}', args.dst)

# src or dst should contain host
def call_rsync(src: str, dst: str):
    cmd = f'rsync -avhH --partial-dir=.rsync-partial --exclude __pycache__/ --delete "{src}" "{dst}"'
    if os.system(cmd) != 0:  # interrupted
        print('Quit rsync in progress.')
        exit()
    print('Finished command:')
    print(cmd)

def parse_args():
    parser_description = """\
push/pull file or folder to/from another path.
Note that trailing slash in src matters: https://unix.stackexchange.com/a/605502

Use cases:
- push current folder to host in the same path:
    rsync_script -p -s ./ -r host
- pull folder from host in the same path:
    rsync_script -l -r host -d folder
- push current folder to host with different username or different folder name:
    rsync_script -p -s folder/ -r host -d "~/new_name"
- rsync local path:
    rsync_script -p -s folder/ -d /path/to/new/location
"""

    parser = argparse.ArgumentParser(
        'rsync_script', description=parser_description,
        formatter_class=argparse.RawDescriptionHelpFormatter,  # preserve \n in description
    )
    mode = parser.add_mutually_exclusive_group(required=True)
    mode.add_argument('-p', '--push', action='store_true', help='push to host')
    mode.add_argument('-l', '--pull', action='store_true', help='pull from host')
    parser.add_argument('-r', '--remote', default='', type=str, help='remote host')
    parser.add_argument('-s', '--src', type=str, help='source')
    parser.add_argument('-d', '--dst', type=str, help='destination')
    # use positional arguments to avoid specifying -s -d
    # parser.add_argument('src', type=str, help='source')
    # nargs='?': optional positional arguments, https://stackoverflow.com/a/4480202/17347885
    # parser.add_argument('dst', nargs='?', type=str, help='destination')
    args = parser.parse_args()

    if args.remote != '':
        args.remote += ':'

    # fill src or dst if not provided
    if args.src is not None and args.dst is None:
        if args.remote == '':
            parser.error('--src and --dst should be specified in local rsync')
        # realpath in python allow invalid path, while the shell version does not by default (unless -m).
        args.dst = os.path.realpath(args.src)
        if args.push and os.path.isdir(args.src) and not args.src.endswith('/'):
            # if dst is auto filled in push and src is dir, trailing slash is needed. Appending in case forgotten.
            print('INFO: Adding trailing slash to src because it is a directory')
            args.src += '/'
    elif args.dst is not None and args.src is None:
        if args.remote == '':
            parser.error('--src and --dst should be specified in local rsync')
        args.src = os.path.realpath(args.dst)
        if args.pull and os.path.isdir(args.dst):
            # print('INFO: Adding trailing slash to src because dst is a directory')
            args.src += '/'  # append trailing slash to copy folder content if pulling and dst is folder
        # otherwise, it's push and we don't know dst, or pulling file, so no trailing slash
    elif args.src is None and args.dst is None:
        # The only way to 'at least one': https://stackoverflow.com/a/6723066/17347885
        parser.error('At least one of --src or --dst should be provided.')
    # else: src and dst is not None, ok

    return args

def confirm(args):
    COLOR_RESET = "\033[0m"
    BOLD_TEXT = "\033[1m"
    UNDERLINE_TEXT = "\033[4m"

    src: str = args.src
    dst: str = args.dst
    # It's unnecessary to check endswith '/' because python basename is empty if has trailing slash
    # Check explicitly only for readability
    if is_src_dir(args) and not src.endswith('/'):
        # hint that the directory will be copied to dst instead of synced
        dst = os.path.join(dst, os.path.basename(src))
    src_remote = args.remote if args.pull else ''
    dst_remote = args.remote if args.push else ''
    msg = (
        f'Sync: {BOLD_TEXT}{src_remote}{UNDERLINE_TEXT}{src}{COLOR_RESET}'
        f' -> {BOLD_TEXT}{dst_remote}{UNDERLINE_TEXT}{dst}{COLOR_RESET}? [Y/n] '
    )
    try:
        confirmation = input(msg).lower()
    except KeyboardInterrupt:
        print('\nQuit rsync.')
        exit()
    if confirmation != '' and not confirmation.startswith('y'):
        print('Quit rsync.')
        exit()
    
def is_src_dir(args):
    if args.pull and args.remote != '':  # src is remote path
        remote = args.remote[:-1]  # remote trailing :
        cmd = f'ssh {remote} "test -d \'{args.src}\'"'
        return os.system(cmd) == 0  # 0 is dir, return code explain: https://stackoverflow.com/a/6466753/17347885
    else:  # src is local path
        return os.path.isdir(args.src)


if __name__ == '__main__':
    main()